#include "imports/stdlib.fc";

const op::withdraw = "op::withdraw"c;
const op::payout = "op::payout"c;

global slice ctx_owner;
global int ctx_nonce;

() load_data() impure {
    var ds = get_data().begin_parse();

    ctx_owner = ds~load_msg_addr();
    ctx_nonce = ds~load_uint(64);

    ds.end_parse();
}

() check_owner(slice sender) {
    throw_unless(501, equal_slice_bits(sender, ctx_owner));
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    
    if (op == op::withdraw) {
        check_owner(sender_address);

        cell msg_body = begin_cell()
            .store_uint(op::payout, 32)
            .end_cell();

        builder msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(0)
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_ref(msg_body);

        ;; send all the remaining balance
        send_raw_message(msg.end_cell(), 128);
        return ();
    }
}

slice owner() method_id {
    load_data();
    return ctx_owner;
}

int nonce() method_id {
    load_data();
    return ctx_nonce;
}
